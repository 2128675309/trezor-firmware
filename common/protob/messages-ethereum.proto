syntax = "proto2";
package hw.trezor.messages.ethereum;

// Sugar for easier handling in Java
option java_package = "com.satoshilabs.trezor.lib.protobuf";
option java_outer_classname = "TrezorMessageEthereum";

import "messages-common.proto";


/**
 * Request: Ask device for public key corresponding to address_n path
 * @start
 * @next EthereumPublicKey
 * @next Failure
 */
message EthereumGetPublicKey {
    repeated uint32 address_n = 1;                                      // BIP-32 path to derive the key from master node
    optional bool show_display = 2;                                     // optionally show on display before sending the result
}

/**
 * Response: Contains public key derived from device private seed
 * @end
 */
message EthereumPublicKey {
    required hw.trezor.messages.common.HDNodeType node = 1;        // BIP32 public node
    required string xpub = 2;        // serialized form of public node
}

/**
 * Request: Ask device for Ethereum address corresponding to address_n path
 * @start
 * @next EthereumAddress
 * @next Failure
 */
message EthereumGetAddress {
    repeated uint32 address_n = 1;  // BIP-32 path to derive the key from master node
    optional bool show_display = 2; // optionally show on display before sending the result
}

/**
 * Response: Contains an Ethereum address derived from device private seed
 * @end
 */
message EthereumAddress {
    optional bytes _old_address = 1 [deprecated=true];  // trezor <1.8.0, <2.1.0 - raw bytes of Ethereum address
    optional string address = 2;                       // Ethereum address as hex-encoded string
}

/**
 * Request: Ask device to sign transaction
 * All fields are optional from the protocol's point of view. Each field defaults to value `0` if missing.
 * Note: the first at most 1024 bytes of data MUST be transmitted as part of this message.
 * @start
 * @next EthereumTxRequest
 * @next Failure
 */
message EthereumSignTx {
    repeated uint32 address_n = 1;          // BIP-32 path to derive the key from master node
    optional bytes nonce = 2;               // <=256 bit unsigned big endian
    optional bytes gas_price = 3;           // <=256 bit unsigned big endian (in wei)
    optional bytes gas_limit = 4;           // <=256 bit unsigned big endian
    optional string to = 11;                // recipient address
    optional bytes value = 6;               // <=256 bit unsigned big endian (in wei)
    optional bytes data_initial_chunk = 7;  // The initial data chunk (<= 1024 bytes)
    optional uint32 data_length = 8;        // Length of transaction payload
    optional uint32 chain_id = 9;           // Chain Id for EIP 155
    optional uint32 tx_type = 10;           // (only for Wanchain)
}

/**
 * Response: Device asks for more data from transaction payload, or returns the signature.
 * If data_length is set, device awaits that many more bytes of payload.
 * Otherwise, the signature_* fields contain the computed transaction signature. All three fields will be present.
 * @end
 * @next EthereumTxAck
 */
message EthereumTxRequest {
    optional uint32 data_length = 1;    // Number of bytes being requested (<= 1024)
    optional uint32 signature_v = 2;    // Computed signature (recovery parameter, limited to 27 or 28)
    optional bytes signature_r = 3;     // Computed signature R component (256 bit)
    optional bytes signature_s = 4;     // Computed signature S component (256 bit)
}

/**
 * Request: Transaction payload data.
 * @next EthereumTxRequest
 */
message EthereumTxAck {
    optional bytes data_chunk = 1;  // Bytes from transaction payload (<= 1024 bytes)
}

/**
 * Request: Ask device to sign message
 * @start
 * @next EthereumMessageSignature
 * @next Failure
 */
message EthereumSignMessage {
    repeated uint32 address_n = 1;  // BIP-32 path to derive the key from master node
    optional bytes message = 2;     // message to be signed
}

/**
 * Response: Signed message
 * @end
 */
message EthereumMessageSignature {
    required bytes signature = 2;   // signature of the message
    required string address = 3;     // address used to sign the message
}


/**
 * Request: Ask device to sign typed data
 * @start
 * @next EthereumTypedDataRequest
 * @next Failure
 */
message EthereumSignTypedData {
    repeated uint32 address_n = 1;                       // BIP-32 path to derive the key from master node
    required string primary_type = 2;                    // name of the root message struct
    optional bool metamask_v4_compat = 3 [default=true]; // use MetaMask v4 (see https://github.com/MetaMask/eth-sig-util/issues/106)
}

/**
 * Response: Device asks for more values from typed data, or returns the signature and address.
 * If member_path is not empty, device awaits the information for this value.
 * Otherwise, the signature field contain the computed transaction signature.
 * @end
 * @next EthereumTypedDataAck
 * @next Failure
 */
message EthereumTypedDataRequest {
    repeated uint32 member_path = 1; // type or value member path requested by device
    optional bool expect_type   = 2; // if true, then device expects type info, otherwise value
    optional bytes signature    = 3; // signature of the message
    optional string address     = 4; // address used to sign the message
}

message EthereumTypedDataStructRequest {
    required string name = 1; // name of the requested struct
}

message EthereumTypedDataStructAck {
    repeated EthereumStructMember members = 1;

    message EthereumStructMember {
        required EthereumFieldType type = 1;
        required string name = 2;
    }

    message EthereumFieldType {
        required EthereumDataType data_type = 1;
        optional uint32 size = 2;                   // for integer types: size in bytes (uint8 has size 1, uint256 has size 32)
                                                    // for bytes types: size in bytes, or unset for dynamic
                                                    // for arrays: size in elements, or unset for dynamic
                                                    // for structs: number of members
                                                    // for string, bool and address: unset
        optional EthereumFieldType entry_type = 3;  // for array types, type of single entry
    }

    enum EthereumDataType {
        UINT = 1;
        INT = 2;
        BYTES = 3;
        STRING = 4;
        BOOL = 5;
        ADDRESS = 6;
        ARRAY = 7;
        STRUCT = 8;
    }
}

message EthereumTypedDataValueRequest {
    repeated uint32 member_path = 1; // member path requested by device
}

message EthereumTypedDataValueAck {
    required bytes value = 1; 
    // * atomic types: value of the member.
    //   Length must match the `size` of the corresponding field type.
    // * array types: number of elements, encoded as uint16.
    // * struct types: undefined, Trezor will not query a struct field.
}

/**
 * Request: Typed data value.
 * If the member is a struct member_value should not be set. If the member is literal num_members should not be set.
 * @next EthereumTypedDataRequest
 */
message EthereumTypedDataAck {
    optional string member_name     = 1; // if expect_type was true, should contain memeber name
    optional string member_type     = 2; // contains member type name
    optional uint32 member_array_n  = 3; // set to 0 when array is dynamic, None when member is not an array
    optional uint32 member_children = 4; // if expect_type was true, should contain its children number
    optional bytes member_value     = 5; // if expect_type was false and value is not struct or array, should contain eth-abi encoded member value
}

/**
 * Request: Ask device to verify message
 * @start
 * @next Success
 * @next Failure
 */
message EthereumVerifyMessage {
    optional bytes signature = 2;   // signature to verify
    optional bytes message = 3;     // message to verify
    optional string address = 4;     // address to verify
}
